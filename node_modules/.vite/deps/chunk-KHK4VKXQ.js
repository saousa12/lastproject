import {
  convertToUnit,
  getCurrentInstanceName,
  propsFactory
} from "./chunk-4CBMZOML.js";
import {
  computed,
  isRef
} from "./chunk-NTQXILLN.js";
import {
  init_define_process_env
} from "./chunk-YCZKCQV3.js";

// node_modules/vuetify/lib/composables/border.mjs
init_define_process_env();
var makeBorderProps = propsFactory({
  border: [Boolean, Number, String]
}, "border");
function useBorder(props) {
  let name = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : getCurrentInstanceName();
  const borderClasses = computed(() => {
    const classes = [];
    if (props.border != null && props.border !== false) {
      classes.push(`${name}--border`);
    }
    if (typeof props.border === "string" && props.border !== "" || props.border === 0) {
      for (const value of String(props.border).split(" ")) {
        classes.push(`border-${value}`);
      }
    }
    return classes;
  });
  return {
    borderClasses
  };
}

// node_modules/vuetify/lib/composables/elevation.mjs
init_define_process_env();
var makeElevationProps = propsFactory({
  elevation: {
    type: [Number, String],
    validator(v) {
      const value = parseInt(v);
      return !isNaN(value) && value >= 0 && value <= 24;
    }
  }
}, "elevation");
function useElevation(props) {
  const elevationClasses = computed(() => {
    const elevation = isRef(props) ? props.value : props.elevation;
    const classes = [];
    if (elevation == null)
      return classes;
    classes.push(`elevation-${elevation}`);
    return classes;
  });
  return {
    elevationClasses
  };
}

// node_modules/vuetify/lib/composables/rounded.mjs
init_define_process_env();
var makeRoundedProps = propsFactory({
  rounded: {
    type: [Boolean, Number, String],
    default: void 0
  }
}, "rounded");
function useRounded(props) {
  let name = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : getCurrentInstanceName();
  const roundedClasses = computed(() => {
    const rounded = isRef(props) ? props.value : props.rounded;
    const classes = [];
    if (rounded === true || rounded === "") {
      classes.push(`${name}--rounded`);
    } else if (typeof rounded === "string" || rounded === 0) {
      for (const value of String(rounded).split(" ")) {
        classes.push(`rounded-${value}`);
      }
    }
    return classes;
  });
  return {
    roundedClasses
  };
}

// node_modules/vuetify/lib/composables/position.mjs
init_define_process_env();
var positionValues = ["static", "relative", "fixed", "absolute", "sticky"];
var makePositionProps = propsFactory({
  absolute: Boolean,
  bottom: [Boolean, Number, String],
  fixed: Boolean,
  left: [Boolean, Number, String],
  position: {
    type: String,
    validator: (v) => positionValues.includes(v)
  },
  right: [Boolean, Number, String],
  top: [Boolean, Number, String]
}, "position");
function usePosition(props) {
  let name = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : getCurrentInstanceName();
  const targets = ["top", "right", "bottom", "left"];
  const positionClasses = computed(() => {
    if (props.fixed)
      return `${name}--fixed`;
    if (props.absolute)
      return `${name}--absolute`;
    return props.position ? `position-${props.position}` : void 0;
  });
  const positionStyles = computed(() => {
    const styles = {};
    for (const target of targets) {
      const prop = props[target];
      if (prop == null || prop === false)
        continue;
      styles[target] = convertToUnit(prop === true ? "0" : String(prop));
    }
    return styles;
  });
  return {
    positionClasses,
    positionStyles
  };
}

export {
  makeBorderProps,
  useBorder,
  makeElevationProps,
  useElevation,
  makeRoundedProps,
  useRounded,
  makePositionProps,
  usePosition
};
//# sourceMappingURL=chunk-KHK4VKXQ.js.map
